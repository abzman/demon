                              1 ;****************************************************************
                              2 ; This file is auto-generated by ddmake from et3400.toml
                              3 ; *** DO NOT EDIT ***
                              4 ;****************************************************************
                              5 
                              6 ; Start of chip memory mapping
                     F800     7 STRTADD = 0xf800
                              8 
                              9 ; 2K ROM
                     0800    10 ROMSIZE = 0x0800
                             11 
                             12 ; Start of ram, needs 7 bytes starting here
                             13 ; On the 6502, you can usually you can count on there being RAM in page 0
                     0000    14 RAMSTRT = 0x0000
                             15 
                             16 ; Start of stack, needs some memory below this address
                     1FFF    17 SSTACK = 0x1fff
                             18 
                             19 ; delay factor
                     0180    20 BIGDEL = 0x0180
                             21 
                             22         .include "../core/dd.def"
                              1 
                     0000     2 ROMEND  .equ    STRTADD+ROMSIZE
                              3 
                              4 
                             23         .include "../core/6800.def"
                              1 
                              2 ; Same for all 6800s
                     FFF8     3 VECTORS .equ    0xfff8      ; location of Vector table
                             24         .include "../io/romio.def"
                              1 ; For Demon Debugger Hardware - Rev D 
                              2 
                     FFA0     3 IOREGR   .equ   STRTADD+0x07a0    ;reserved region for IO READ
                     FFC0     4 IOREGW   .equ   STRTADD+0x07c0    ;reserved region for IO WRITE
                              5 
                     FFA0     6 IOADD    .equ   IOREGR            ;start of region
                     FFE0     7 IOEND    .equ   STRTADD+0x07e0    ;end of region
                             25 
                             26 ;------- region1  -----------------------------------------------
                             27 
                             28         .bank   region1 (base=STRTADD, size=IOADD-STRTADD)
                             29         .area   region1 (ABS, BANK=region1)
                             30 
                             31 ;
                             32 ;       START CODE
                             33 ;
   F800                      34 START:
   F800 0F            [ 2]   35         sei              ; Disable interrupts - we don't handle them
   F801 8E 1F FF      [ 3]   36         lds     #SSTACK  ; set up the stack
                             37 ;       YOUR CODE CAN GO HERE
   F804 7E F8 07      [ 3]   38         jmp     INIT
                             39 
                             40         .include "../core/6800_main.asm"
                              1 
                              2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              3 ; RAM Variables 
                              4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              5 
                     0000     6 OUTBUF  .equ    RAMSTRT         ;buffer for output states
                     0001     7 BREG    .equ    RAMSTRT+0x01    ;general purpose
                     0002     8 C       .equ    RAMSTRT+0x02    ;general purpose
                     0003     9 CMDBUF0 .equ    RAMSTRT+0x03    ;command buffer
                     0004    10 CMDBUF1 .equ    RAMSTRT+0x04    ;command buffer
                     0005    11 CMDBUF2 .equ    RAMSTRT+0x05    ;command buffer
                     0006    12 CMDBUF3 .equ    RAMSTRT+0x06    ;command buffer
                             13 
                             14 ; I2C ADDRESSING
                     0011    15 I2CRADR .equ    0x11        ; I2C read address  - I2C address 0x08
                     0010    16 I2CWADR .equ    0x10        ; I2C write address - I2C address 0x08
                             17 
   F807                      18 INIT:
   F807 86 00         [ 2]   19         ldaa    #0x00
   F809 97 00         [ 4]   20         staa    OUTBUF
                             21 
                             22 ; Main routine
   F80B                      23 MAIN:
   F80B BD F9 11      [ 9]   24         jsr     EVERY
   F80E BD F8 CB      [ 9]   25         jsr     POLL
   F811 25 F8         [ 4]   26         bcs     MAIN
   F813 86 01         [ 2]   27         ldaa    #BIGDEL>>8
   F815 97 01         [ 4]   28         staa    BREG
   F817 86 80         [ 2]   29         ldaa    #BIGDEL%256
   F819 97 02         [ 4]   30         staa    C
   F81B                      31 MLOOP:
   F81B 96 02         [ 3]   32         ldaa    C
   F81D 27 06         [ 4]   33         beq     DECBOTH
   F81F 7A 00 02      [ 6]   34         dec     C
   F822 7E F8 1B      [ 3]   35         jmp     MLOOP
   F825                      36 DECBOTH:
   F825 96 01         [ 3]   37         ldaa    BREG
   F827 27 E2         [ 4]   38         beq     MAIN
   F829 7A 00 02      [ 6]   39         dec     C
   F82C 7A 00 01      [ 6]   40         dec     BREG
   F82F 7E F8 1B      [ 3]   41         jmp     MLOOP
                             42 
                             43 ; Delay for half a bit time
   F832 39            [ 5]   44 I2CDLY: rts             ; TBD - this is plenty?
                             45 
                             46 ; I2C Start Condition
   F833                      47 I2CSTART:
   F833 BD F9 51      [ 9]   48         jsr    CLRSDA      
   F836 BD F9 28      [ 9]   49         jsr    CLRSCL
   F839 39            [ 5]   50         rts
                             51 
                             52 ; I2C Stop Condition
                             53 ; Uses HL
                             54 ; Destroys A
   F83A                      55 I2CSTOP:
   F83A BD F9 51      [ 9]   56         jsr    CLRSDA
   F83D BD F9 12      [ 9]   57         jsr    SETSCL
   F840 BD F9 3B      [ 9]   58         jsr    SETSDA
   F843 39            [ 5]   59         rts
                             60         
   F844                      61 I2CRBIT:
   F844 BD F9 3B      [ 9]   62         jsr     SETSDA
   F847 BD F9 12      [ 9]   63         jsr     SETSCL
   F84A BD F9 67      [ 9]   64         jsr     READSDA ; sets/clears carry flag
   F84D BD F9 28      [ 9]   65         jsr     CLRSCL
   F850 39            [ 5]   66         rts             ; carry flag still good here
                             67 
   F851                      68 I2CWBIT:
   F851 24 06         [ 4]   69         bcc     DOCLR
   F853 BD F9 3B      [ 9]   70         jsr     SETSDA
   F856 7E F8 5C      [ 3]   71         jmp     AHEAD
   F859                      72 DOCLR:
   F859 BD F9 51      [ 9]   73         jsr     CLRSDA
   F85C                      74 AHEAD:
   F85C BD F9 12      [ 9]   75         jsr     SETSCL
   F85F BD F9 28      [ 9]   76         jsr     CLRSCL
   F862 39            [ 5]   77         rts
                             78         
   F863                      79 I2CWBYTE:
   F863 36            [ 4]   80         psha
   F864 86 08         [ 2]   81         ldaa    #0x08
   F866 97 01         [ 4]   82         staa    BREG
   F868 32            [ 4]   83         pula
   F869                      84 ILOOP:
   F869 49            [ 2]   85         rola
   F86A 36            [ 4]   86         psha
   F86B BD F8 51      [ 9]   87         jsr     I2CWBIT
   F86E 32            [ 4]   88         pula
   F86F 7A 00 01      [ 6]   89         dec     BREG
   F872 26 F5         [ 4]   90         bne     ILOOP
   F874 BD F8 44      [ 9]   91         jsr     I2CRBIT
   F877 39            [ 5]   92         rts
                             93         
   F878                      94 I2CRBYTE:
   F878 86 08         [ 2]   95         ldaa    #0x08
   F87A 97 01         [ 4]   96         staa    BREG
   F87C 86 00         [ 2]   97         ldaa    #0x00
   F87E 97 02         [ 4]   98         staa    C
   F880                      99 LOOP3:
   F880 BD F8 44      [ 9]  100         jsr     I2CRBIT     ; get bit in carry flag
   F883 79 00 02      [ 6]  101         rol     C           ; rotate carry into bit0 of C register
   F886 7A 00 01      [ 6]  102         dec     BREG
   F889 26 F5         [ 4]  103         bne     LOOP3
   F88B 0C            [ 2]  104         clc                 ; clear carry flag              
   F88C BD F8 51      [ 9]  105         jsr     I2CWBIT
   F88F 96 02         [ 3]  106         ldaa    C
   F891 39            [ 5]  107         rts
                            108 
   F892                     109 I2CRREQ:
   F892 BD F8 33      [ 9]  110         jsr     I2CSTART
   F895 86 11         [ 2]  111         ldaa    #I2CRADR
   F897 BD F8 63      [ 9]  112         jsr     I2CWBYTE
   F89A 25 17         [ 4]  113         bcs     SKIP
   F89C BD F8 78      [ 9]  114         jsr     I2CRBYTE
   F89F 97 03         [ 4]  115         staa    CMDBUF0
   F8A1 BD F8 78      [ 9]  116         jsr     I2CRBYTE
   F8A4 97 04         [ 4]  117         staa    CMDBUF1
   F8A6 BD F8 78      [ 9]  118         jsr     I2CRBYTE
   F8A9 97 05         [ 4]  119         staa    CMDBUF2
   F8AB BD F8 78      [ 9]  120         jsr     I2CRBYTE
   F8AE 97 06         [ 4]  121         staa    CMDBUF3
   F8B0 7E F8 C7      [ 3]  122         jmp     ENDI2C
                            123     
   F8B3                     124 SKIP:                       ; If no device present, fake an idle response
   F8B3 86 2E         [ 2]  125         ldaa    #0x2e  ; '.'
   F8B5 97 03         [ 4]  126         staa    CMDBUF0
   F8B7 7E F8 C7      [ 3]  127         jmp     ENDI2C
                            128 
   F8BA                     129 I2CSRESP:
   F8BA 36            [ 4]  130         psha
   F8BB BD F8 33      [ 9]  131         jsr     I2CSTART
   F8BE 86 10         [ 2]  132         ldaa    #I2CWADR
   F8C0 BD F8 63      [ 9]  133         jsr     I2CWBYTE
   F8C3 32            [ 4]  134         pula
   F8C4 BD F8 63      [ 9]  135         jsr     I2CWBYTE
   F8C7                     136 ENDI2C:
   F8C7 BD F8 3A      [ 9]  137         jsr     I2CSTOP
   F8CA 39            [ 5]  138         rts
                            139 
   F8CB                     140 POLL:
   F8CB BD F8 92      [ 9]  141         jsr     I2CRREQ
   F8CE 96 03         [ 3]  142         ldaa    CMDBUF0
   F8D0 81 52         [ 2]  143         cmpa    #0x52           ; 'R' - Read memory
   F8D2 27 0A         [ 4]  144         beq     MREAD
   F8D4 81 57         [ 2]  145         cmpa    #0x57           ; 'W' - Write memory
   F8D6 27 10         [ 4]  146         beq     MWRITE
   F8D8 81 43         [ 2]  147         cmpa    #0x43           ; 'C' - Call subroutine
   F8DA 27 28         [ 4]  148         beq     REMCALL
   F8DC 0C            [ 2]  149         clc
   F8DD 39            [ 5]  150         rts
                            151 
   F8DE                     152 MREAD:
   F8DE BD F8 F6      [ 9]  153         jsr     LOADBC
   F8E1 DE 01         [ 4]  154         ldx     BREG
   F8E3 A6 00         [ 5]  155         ldaa    0,X
   F8E5 7E F8 FF      [ 3]  156         jmp     SRESP
   F8E8                     157 MWRITE:
   F8E8 BD F8 F6      [ 9]  158         jsr     LOADBC
   F8EB 96 06         [ 3]  159         ldaa    CMDBUF3
   F8ED DE 01         [ 4]  160         ldx     BREG
   F8EF A7 00         [ 6]  161         staa    0,X
   F8F1 86 57         [ 2]  162         ldaa    #0x57   ;'W'
   F8F3 7E F8 FF      [ 3]  163         jmp     SRESP
   F8F6                     164 LOADBC:
   F8F6 96 05         [ 3]  165         ldaa    CMDBUF2
   F8F8 97 01         [ 4]  166         staa    BREG
   F8FA 96 04         [ 3]  167         ldaa    CMDBUF1
   F8FC 97 02         [ 4]  168         staa    C
   F8FE 39            [ 5]  169         rts
                            170         
   F8FF                     171 SRESP:
   F8FF BD F8 BA      [ 9]  172         jsr    I2CSRESP
   F902                     173 RHERE:
   F902 0D            [ 2]  174         sec
   F903 39            [ 5]  175         rts
   F904                     176 REMCALL:
   F904 86 F7         [ 2]  177         ldaa    #>(START-1)
   F906 36            [ 4]  178         psha
   F907 86 FF         [ 2]  179         ldaa    #<(START-1)
   F909 36            [ 4]  180         psha
   F90A BD F8 F6      [ 9]  181         jsr     LOADBC
   F90D DE 01         [ 4]  182         ldx     BREG
   F90F 6E 00         [ 4]  183         jmp     0,X
                            184         
                            185 ;;;;;;;;;;
                             41 ;
                             42 ;       EVERY CODE
                             43 ;
   F911                      44 EVERY:
                             45 ;       YOUR CODE CAN GO HERE
   F911 39            [ 5]   46         rts
                             47 
                             48         .include "../io/6800_romio.asm"
   F912 96 00         [ 3]    1 SETSCL: ldaa    OUTBUF
   F914 8A 01         [ 2]    2         oraa    #0x01
   F916 97 00         [ 4]    3         staa    OUTBUF
   F918 8B FF         [ 2]    4         adda    #>(IOREGW)
   F91A 97 02         [ 4]    5         staa    C
   F91C 86 C0         [ 2]    6         ldaa    #<(IOREGW)
   F91E 97 01         [ 4]    7         staa    BREG
   F920 DE 01         [ 4]    8         ldx     BREG
   F922 A6 00         [ 5]    9         ldaa    0,X
   F924 BD F8 32      [ 9]   10         jsr     I2CDLY
   F927 39            [ 5]   11         rts
                             12 
   F928 96 00         [ 3]   13 CLRSCL: ldaa    OUTBUF
   F92A 84 1E         [ 2]   14         anda    #0x1e
   F92C 97 00         [ 4]   15         staa    OUTBUF
   F92E 8B FF         [ 2]   16         adda    #>(IOREGW)
   F930 97 02         [ 4]   17         staa    C
   F932 86 C0         [ 2]   18         ldaa    #<(IOREGW)
   F934 97 01         [ 4]   19         staa    BREG
   F936 DE 01         [ 4]   20         ldx     BREG
   F938 A6 00         [ 5]   21         ldaa    0,X
   F93A 39            [ 5]   22         rts
                             23 
   F93B 96 00         [ 3]   24 SETSDA: ldaa    OUTBUF
   F93D 84 1D         [ 2]   25         anda    #0x1d
   F93F 97 00         [ 4]   26         staa    OUTBUF
   F941 8B FF         [ 2]   27         adda    #>(IOREGW)
   F943 97 02         [ 4]   28         staa    C
   F945 86 C0         [ 2]   29         ldaa    #<(IOREGW)
   F947 97 01         [ 4]   30         staa    BREG
   F949 DE 01         [ 4]   31         ldx     BREG
   F94B A6 00         [ 5]   32         ldaa    0,X
   F94D BD F8 32      [ 9]   33         jsr     I2CDLY
   F950 39            [ 5]   34         rts
                             35 
   F951 96 00         [ 3]   36 CLRSDA: ldaa    OUTBUF
   F953 8A 02         [ 2]   37         oraa    #0x02
   F955 97 00         [ 4]   38         staa    OUTBUF
   F957 8B FF         [ 2]   39         adda    #>(IOREGW)
   F959 97 02         [ 4]   40         staa    C
   F95B 86 C0         [ 2]   41         ldaa    #<(IOREGW)
   F95D 97 01         [ 4]   42         staa    BREG
   F95F DE 01         [ 4]   43         ldx     BREG
   F961 A6 00         [ 5]   44         ldaa    0,X
   F963 BD F8 32      [ 9]   45         jsr     I2CDLY
   F966 39            [ 5]   46         rts
                             47 
   F967                      48 READSDA:
   F967 96 00         [ 3]   49         ldaa    OUTBUF
   F969 8B FF         [ 2]   50         adda    #>(IOREGR)
   F96B 97 02         [ 4]   51         staa    C
   F96D 86 A0         [ 2]   52         ldaa    #<(IOREGR)
   F96F 97 01         [ 4]   53         staa    BREG
   F971 DE 01         [ 4]   54         ldx     BREG
   F973 A6 00         [ 5]   55         ldaa    0,X
   F975 46            [ 2]   56         rora
   F976 39            [ 5]   57         rts
                             58                              
                             49 ;
                             50 ;       NMI HANDLER
                             51 ;
   F977                      52 NMI:
   F977 3B            [10]   53         rti
                             54 
                             55 
                             56 ;------- region2  -----------------------------------------------
                             57 
                             58         .bank   region2 (base=IOADD, size=IOEND-IOADD)
                             59         .area   region2 (ABS, BANK=region2)
                             60 
                             61         .include "../io/romio_table.asm"
                              1 
                              2 ; 
                              3 ; For Demon Debugger Hardware - Rev D 
                              4 ;
                              5 ; In earlier hardware designs, I tried to capture the address bus bits on a 
                              6 ; read cycle, to use to write to the Arduino.  But it turns out it is impossible
                              7 ; to know exactly when to sample these address bits across all platforms, designs, and 
                              8 ; clock speeds
                              9 ;
                             10 ; The solution I came up with was to make sure the data bus contains the same information
                             11 ; as the lower address bus during these read cycles, so that I can sample the data bus just like the 
                             12 ; CPU would.
                             13 ;
                             14 ; This block of memory, starting at 0x07c0, is filled with consecutive integers.
                             15 ; When the CPU reads from a location, the data bus matches the lower bits of the address bus.  
                             16 ; And the data bus read by the CPU is also written to the Arduino.
                             17 ; 
                             18 ; Note: Currently, only the bottom two bits are used, but reserving the memory
                             19 ; this way insures that up to 5 bits could be used 
                             20 ; 
                             21         ; ROMIO READ Area - reserved
   FFA0 FF FF FF FF FF FF    22         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
   FFB0 FF FF FF FF FF FF    23         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
                             24 
                             25         ; ROMIO WRITE Area - data is used
   FFC0 00 01 02 03 04 05    26         .DB     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
        06 07 08 09 0A 0B
        0C 0D 0E 0F
   FFD0 10 11 12 13 14 15    27         .DB     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
        16 17 18 19 1A 1B
        1C 1D 1E 1F
                             28 
                             62 
                             63 ;------- region3  -----------------------------------------------
                             64 
                             65         .bank   region3 (base=VECTORS, size=ROMSIZE-VECTORS)
                             66         .area   region3 (ABS, BANK=region3)
                             67 
                             68         .include "../core/6800_vectors.asm"
   FFF8 F8 00                 1         .dw     START   ;IRQ
   FFFA F8 00                 2         .dw     START   ;SWI
   FFFC F9 77                 3         .dw     NMI
   FFFE F8 00                 4         .dw     START
                             69 
