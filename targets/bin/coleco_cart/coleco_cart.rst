                              1 ;****************************************************************
                              2 ; This file is auto-generated by ddmake from coleco_cart.toml
                              3 ; *** DO NOT EDIT ***
                              4 ;****************************************************************
                              5 
                              6 ; Start of chip memory mapping
                     8000     7 STRTADD = 0x8000
                              8 
                              9 ; 2K ROM
                     0800    10 ROMSIZE = 0x0800
                             11 
                             12 ; The code actually needs 4 bytes ram at this address for the command buffer.
                             13 ; However, stack also starts here, and will grow down (towards 0) from this point.
                             14 ; So, we need some above and below this address.  I generally choose the
                             15 ; Top of RAM minus 16
                     77F0    16 RAMADDR = 0x77f0
                             17 
                             18 ; delay factor
                     0180    19 BIGDEL = 0x0180
                             20 
                             21         .include "../core/dd.def"
                              1 
                     8800     2 ROMEND  .equ    STRTADD+ROMSIZE
                              3 
                              4 
                             22         .include "../core/z80.def"
                              1 ; Same for all Z80s
                     0038     2 IRQADD  .equ    0x0038      ; location of IRQ handler
                     0066     3 NMIADD  .equ    0x0066      ; location of NMI handler
                             23         .include "../io/romio.def"
                              1 ; For Demon Debugger Hardware - Rev D 
                              2 
                     87A0     3 IOREGR   .equ   STRTADD+0x07a0    ;reserved region for IO READ
                     87C0     4 IOREGW   .equ   STRTADD+0x07c0    ;reserved region for IO WRITE
                              5 
                     87A0     6 IOADD    .equ   IOREGR            ;start of region
                     87E0     7 IOEND    .equ   STRTADD+0x07e0    ;end of region
                             24 
                             25 ;------- region1  -----------------------------------------------
                             26 
                             27         .bank   region1 (base=STRTADD, size=IOADD-STRTADD)
                             28         .area   region1 (ABS, BANK=region1)
                             29 
   8000 AA                   30         .db	0xaa	    ; cartridge signature
   8001 55                   31     	.db	0x55
                             32     	
   8002 00 00                33     	.dw     0x0000
   8004 00 00                34     	.dw     0x0000
   8006 00 00                35     	.dw     0x0000
   8008 00 00                36     	.dw     0x0000
   800A 47 80                37     	.dw     START
   800C C3 08 00      [10]   38     	JP      0x0008
   800F C3 10 00      [10]   39     	JP      0x0010
   8012 C3 18 00      [10]   40     	JP      0x0018
   8015 C3 20 00      [10]   41     	JP      0x0020
   8018 C3 28 00      [10]   42     	JP      0x0028
   801B C3 30 00      [10]   43     	JP      0x0030
   801E C3 38 00      [10]   44     	JP      IRQADD
   8021 C3 66 00      [10]   45     	JP      NMIADD
                             46 
   8024 42 59 3A 20 45 56    47     	.asciz  "BY: EVAN&FRANK/DEMON DEBUGGER/2019"
        41 4E 26 46 52 41
        4E 4B 2F 44 45 4D
        4F 4E 20 44 45 42
        55 47 47 45 52 2F
        32 30 31 39 00
                             48 
                             49 ;
                             50 ;       START CODE
                             51 ;
   8047                      52 START:
   8047 F3            [ 4]   53         DI                  ; Disable interrupts - we don't handle them
   8048 31 F0 77      [10]   54         LD      SP,RAMADDR  ; have to set valid SP
                             55 ;       YOUR CODE CAN GO HERE
   804B C3 4E 80      [10]   56         JP      INIT
                             57 
                             58         .include "../core/z80_main.asm"
                              1 ; I2C ADDRESSING
                     0011     2 I2CRADR .equ    0x11        ; I2C read address  - I2C address 0x08
                     0010     3 I2CWADR .equ    0x10        ; I2C write address - I2C address 0x08
                              4 
                              5 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              6 ; RAM Variables	
                              7 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              8 
                     77F0     9 CMDBUF  .equ    RAMADDR     ; Need only 4 bytes of ram for command buffer
                             10 
   804E                      11 INIT:
   804E DD 21 F0 77   [14]   12         LD      IX,CMDBUF   ; Easy to index command buffer
   8052 16 00         [ 7]   13         LD      D,#0x00     ; initialize D to prevent index overflow
                             14 
                             15 ; Main routine
   8054                      16 MAIN:
   8054 CD 5A 81      [17]   17         CALL    EVERY
   8057 CD FD 80      [17]   18         CALL    POLL
   805A DA 54 80      [10]   19         JP      C,MAIN
                             20         
   805D 01 80 01      [10]   21         LD      BC,BIGDEL
   8060                      22 DLOOP:
   8060 0B            [ 6]   23         DEC     BC
   8061 79            [ 4]   24         LD      A,C
   8062 B0            [ 4]   25         OR      B
   8063 C2 60 80      [10]   26         JP      NZ,DLOOP
   8066 C3 54 80      [10]   27         JP      MAIN
                             28 
                             29 ; Delay for half a bit time
   8069                      30 I2CDELAY:
   8069 C9            [10]   31         RET     ; This is plenty
                             32 
                             33 ; I2C Start Condition
                             34 ; Uses HL
                             35 ; Destroys A
   806A                      36 I2CSTART:
   806A CD 88 81      [17]   37         CALL    CLRSDA      
   806D CD 6B 81      [17]   38         CALL    CLRSCL
   8070 C9            [10]   39         RET
                             40 
                             41 ; I2C Stop Condition
                             42 ; Uses HL
                             43 ; Destroys A
   8071                      44 I2CSTOP:
   8071 CD 88 81      [17]   45         CALL    CLRSDA
   8074 CD 5B 81      [17]   46         CALL    SETSCL
   8077 CD 78 81      [17]   47         CALL    SETSDA
   807A C9            [10]   48         RET
                             49 
                             50 ; I2C Read Bit routine
                             51 ; Returns bit in carry blag
                             52 ; Destroys A
   807B                      53 I2CRBIT:
   807B CD 78 81      [17]   54         CALL    SETSDA
   807E CD 5B 81      [17]   55         CALL    SETSCL
   8081 CD 98 81      [17]   56         CALL    READSDA
   8084 F5            [11]   57         PUSH    AF          ; save carry flag
   8085 CD 6B 81      [17]   58         CALL    CLRSCL
   8088 F1            [10]   59         POP     AF          ; rv in carry flag
   8089 C9            [10]   60         RET
                             61 
                             62 ; I2C Write Bit routine
                             63 ; Takes carry flag
                             64 ; Destroys A
   808A                      65 I2CWBIT:
   808A 30 05         [12]   66         JR      NC,DOCLR
   808C CD 78 81      [17]   67         CALL    SETSDA
   808F 18 03         [12]   68         JR      AHEAD
   8091                      69 DOCLR:
   8091 CD 88 81      [17]   70         CALL    CLRSDA
   8094                      71 AHEAD:
   8094 CD 5B 81      [17]   72         CALL    SETSCL
   8097 CD 6B 81      [17]   73         CALL    CLRSCL
   809A C9            [10]   74         RET
                             75 
                             76 ; I2C Write Byte routine
                             77 ; Takes A
                             78 ; Destroys B
                             79 ; Returns carry bit
   809B                      80 I2CWBYTE:
   809B 06 08         [ 7]   81         LD      B,8
   809D                      82 ILOOP:
   809D C5            [11]   83         PUSH    BC          ; save B
   809E CB 07         [ 8]   84         RLC     A    
   80A0 F5            [11]   85         PUSH    AF          ; save A
   80A1 CD 8A 80      [17]   86         CALL    I2CWBIT
   80A4 F1            [10]   87         POP     AF
   80A5 C1            [10]   88         POP     BC
   80A6 10 F5         [13]   89         DJNZ    ILOOP
   80A8 CD 7B 80      [17]   90         CALL    I2CRBIT
   80AB C9            [10]   91         RET
                             92 
                             93 ; I2C Read Byte routine
                             94 ; Destroys BC
                             95 ; Returns A
   80AC                      96 I2CRBYTE:
   80AC 06 08         [ 7]   97         LD      B,8
   80AE 0E 00         [ 7]   98         LD      C,0
   80B0                      99 LOOP3:
   80B0 C5            [11]  100         PUSH    BC
   80B1 CD 7B 80      [17]  101         CALL    I2CRBIT     ; get bit in carry flag
   80B4 C1            [10]  102         POP     BC
   80B5 CB 11         [ 8]  103         RL      C           ; rotate carry into bit0 of C register
   80B7 10 F7         [13]  104         DJNZ    LOOP3
   80B9 AF            [ 4]  105         XOR     A           ; clear carry flag              
   80BA C5            [11]  106         PUSH    BC
   80BB CD 8A 80      [17]  107         CALL    I2CWBIT
   80BE C1            [10]  108         POP     BC
   80BF 79            [ 4]  109         LD      A,C
   80C0 C9            [10]  110         RET
                            111 ;
                            112 
                            113 ; Read 4-byte I2C Command from device into CMDBUF
                            114 ; Uses HL
                            115 ; Destroys A,BC,HL
   80C1                     116 I2CRREQ:
   80C1 CD 6A 80      [17]  117         CALL    I2CSTART
   80C4 3E 11         [ 7]  118         LD      A,I2CRADR
   80C6 CD 9B 80      [17]  119         CALL    I2CWBYTE
   80C9 38 1A         [12]  120         JR      C,SKIP
   80CB CD AC 80      [17]  121         CALL    I2CRBYTE
   80CE DD 77 00      [19]  122         LD      (IX),A
   80D1 CD AC 80      [17]  123         CALL    I2CRBYTE
   80D4 DD 77 01      [19]  124         LD      (IX+1),A  
   80D7 CD AC 80      [17]  125         CALL    I2CRBYTE
   80DA DD 77 02      [19]  126         LD      (IX+2),A
   80DD CD AC 80      [17]  127         CALL    I2CRBYTE
   80E0 DD 77 03      [19]  128         LD      (IX+3),A
   80E3 18 14         [12]  129         JR      ENDI2C
                            130     
   80E5                     131 SKIP:                       ; If no device present, fake an idle response
   80E5 3E 2E         [ 7]  132         LD      A,0x2e  ; '.'
   80E7 DD 77 00      [19]  133         LD      (IX),A
   80EA 18 0D         [12]  134         JR      ENDI2C
                            135 
   80EC                     136 I2CSRESP:
   80EC F5            [11]  137         PUSH    AF
   80ED CD 6A 80      [17]  138         CALL    I2CSTART
   80F0 3E 10         [ 7]  139         LD      A,I2CWADR
   80F2 CD 9B 80      [17]  140         CALL    I2CWBYTE
   80F5 F1            [10]  141         POP     AF
   80F6 CD 9B 80      [17]  142         CALL    I2CWBYTE
   80F9                     143 ENDI2C:
   80F9 CD 71 80      [17]  144         CALL    I2CSTOP
   80FC C9            [10]  145         RET
                            146 ;
                            147 
                            148 ; Main Polling loop
                            149 ; Return carry flag if we got a valid command (not idle)
   80FD                     150 POLL:
   80FD CD C1 80      [17]  151         CALL    I2CRREQ
   8100 DD 7E 00      [19]  152         LD      A,(IX)
   8103 FE 52         [ 7]  153         CP      0x52    ; 'R' - Read memory
   8105 28 1B         [12]  154         JR      Z,MREAD
   8107 FE 57         [ 7]  155         CP      0x57    ; 'W' - Write memory
   8109 28 1D         [12]  156         JR      Z,MWRITE
   810B FE 49         [ 7]  157         CP      0x49    ; 'I' - Input from port
   810D 28 2D         [12]  158         JR      Z,PREAD
   810F FE 4F         [ 7]  159         CP      0x4F    ; 'O' - Output from port
   8111 28 30         [12]  160         JR      Z,PWRITE
   8113 FE 43         [ 7]  161         CP      0x43    ; 'C' - Call subroutine
   8115 28 3B         [12]  162         JR      Z,REMCALL
   8117 3F            [ 4]  163         CCF
   8118 C9            [10]  164         RET
   8119                     165 LOADHL:
   8119 DD 7E 01      [19]  166         LD      A,(IX+1)
   811C 67            [ 4]  167         LD      H,A
   811D DD 7E 02      [19]  168         LD      A,(IX+2)
   8120 6F            [ 4]  169         LD      L,A
   8121 C9            [10]  170         RET    
   8122                     171 MREAD:
   8122 CD 33 81      [17]  172         CALL    LOADBC
   8125 0A            [ 7]  173         LD      A,(BC)
   8126 18 25         [12]  174         JR      SRESP
   8128                     175 MWRITE:
   8128 CD 33 81      [17]  176         CALL    LOADBC
   812B DD 7E 03      [19]  177         LD      A,(IX+3)
   812E 02            [ 7]  178         LD      (BC),A
   812F 3E 57         [ 7]  179         LD      A,0x57  ;'W'
   8131 18 1A         [12]  180         JR      SRESP
   8133                     181 LOADBC:
   8133 DD 7E 01      [19]  182         LD      A,(IX+1)
   8136 47            [ 4]  183         LD      B,A
   8137 DD 7E 02      [19]  184         LD      A,(IX+2)
   813A 4F            [ 4]  185         LD      C,A
   813B C9            [10]  186         RET
   813C                     187 PREAD:
   813C CD 33 81      [17]  188         CALL    LOADBC
   813F ED 78         [12]  189         IN      A,(C)
   8141 18 0A         [12]  190         JR      SRESP
   8143                     191 PWRITE:
   8143 CD 33 81      [17]  192         CALL    LOADBC
   8146 DD 7E 03      [19]  193         LD      A,(IX+3)
   8149 ED 79         [12]  194         OUT     (C),A
   814B 3E 4F         [ 7]  195         LD      A,0x4F  ;'O'
   814D                     196 SRESP:
   814D CD EC 80      [17]  197         CALL    I2CSRESP
   8150                     198 RHERE:
   8150 37            [ 4]  199         SCF
   8151 C9            [10]  200         RET
   8152                     201 REMCALL:
   8152 21 47 80      [10]  202         LD      HL,START
   8155 E5            [11]  203         PUSH    HL
   8156 CD 19 81      [17]  204         CALL    LOADHL
   8159 E9            [ 4]  205         JP      (HL)
                            206 
                             59 ;
                             60 ;       EVERY CODE
                             61 ;
   815A                      62 EVERY:
                             63 ;       YOUR CODE CAN GO HERE
   815A C9            [10]   64         RET
                             65 
                             66         .include "../io/z80_romio.asm"
                              1 
                              2 ; For Demon Debugger Hardware - Rev D 
                              3 
                              4 ; Set the SCL pin high
                              5 ; D is the global output buffer
                              6 ; Destroys A
   815B                       7 SETSCL:
   815B 7A            [ 4]    8         LD      A,D
   815C F6 01         [ 7]    9         OR      0x01
   815E 57            [ 4]   10         LD      D,A
   815F E5            [11]   11         PUSH    HL
   8160 26 87         [ 7]   12         LD      H,#>IOREGW
   8162 C6 C0         [ 7]   13         ADD     A,#<IOREGW 
   8164 6F            [ 4]   14         LD      L,A
   8165 7E            [ 7]   15         LD      A,(HL)
   8166 E1            [10]   16         POP     HL
   8167 CD 69 80      [17]   17         CALL    I2CDELAY
   816A C9            [10]   18         RET
                             19     
                             20 ; Set the SCL pin low
                             21 ; D is the global output buffer
                             22 ; Destroys A
   816B                      23 CLRSCL:
   816B 7A            [ 4]   24         LD      A,D
   816C E6 1E         [ 7]   25         AND     0x1E
   816E 57            [ 4]   26         LD      D,A
   816F E5            [11]   27         PUSH    HL
   8170 26 87         [ 7]   28         LD      H,#>IOREGW
   8172 C6 C0         [ 7]   29         ADD     A,#<IOREGW 
   8174 6F            [ 4]   30         LD      L,A
   8175 7E            [ 7]   31         LD      A,(HL)
   8176 E1            [10]   32         POP     HL
   8177 C9            [10]   33         RET
                             34 
                             35 ; Set the DOUT pin low
                             36 ; D is the global output buffer
                             37 ; Destroys A 
   8178                      38 SETSDA:
   8178 7A            [ 4]   39         LD      A,D
   8179 E6 1D         [ 7]   40         AND     0x1D
   817B 57            [ 4]   41         LD      D,A
   817C E5            [11]   42         PUSH    HL
   817D 26 87         [ 7]   43         LD      H,#>IOREGW
   817F C6 C0         [ 7]   44         ADD     A,#<IOREGW 
   8181 6F            [ 4]   45         LD      L,A
   8182 7E            [ 7]   46         LD      A,(HL)
   8183 E1            [10]   47         POP     HL
   8184 CD 69 80      [17]   48         CALL    I2CDELAY
   8187 C9            [10]   49         RET
                             50 
                             51 ; Set the DOUT pin high
                             52 ; D is the global output buffer
                             53 ; Destroys A  
   8188                      54 CLRSDA:
   8188 7A            [ 4]   55         LD      A,D
   8189 F6 02         [ 7]   56         OR      0x02
   818B 57            [ 4]   57         LD      D,A
   818C E5            [11]   58         PUSH    HL
   818D 26 87         [ 7]   59         LD      H,#>IOREGW
   818F C6 C0         [ 7]   60         ADD     A,#<IOREGW 
   8191 6F            [ 4]   61         LD      L,A
   8192 7E            [ 7]   62         LD      A,(HL)
   8193 E1            [10]   63         POP     HL
   8194 CD 69 80      [17]   64         CALL    I2CDELAY
   8197 C9            [10]   65         RET
                             66 
                             67 ; Read the DIN pin 
                             68 ; returns bit in carry flag    
   8198                      69 READSDA:
   8198 7A            [ 4]   70         LD      A,D
   8199 E5            [11]   71         PUSH    HL
   819A 26 87         [ 7]   72         LD      H,#>IOREGR
   819C C6 A0         [ 7]   73         ADD     A,#<IOREGR
   819E 6F            [ 4]   74         LD      L,A
   819F 7E            [ 7]   75         LD      A,(HL)
   81A0 E1            [10]   76         POP     HL
   81A1 CB 3F         [ 8]   77         SRL     A           ;carry flag
   81A3 C9            [10]   78         RET
                             67 
                             68 ;------- region2  -----------------------------------------------
                             69 
                             70         .bank   region2 (base=IOADD, size=IOEND-IOADD)
                             71         .area   region2 (ABS, BANK=region2)
                             72 
                             73         .include "../io/romio_table.asm"
                              1 
                              2 ; 
                              3 ; For Demon Debugger Hardware - Rev D 
                              4 ;
                              5 ; In earlier hardware designs, I tried to capture the address bus bits on a 
                              6 ; read cycle, to use to write to the Arduino.  But it turns out it is impossible
                              7 ; to know exactly when to sample these address bits across all platforms, designs, and 
                              8 ; clock speeds
                              9 ;
                             10 ; The solution I came up with was to make sure the data bus contains the same information
                             11 ; as the lower address bus during these read cycles, so that I can sample the data bus just like the 
                             12 ; CPU would.
                             13 ;
                             14 ; This block of memory, starting at 0x07c0, is filled with consecutive integers.
                             15 ; When the CPU reads from a location, the data bus matches the lower bits of the address bus.  
                             16 ; And the data bus read by the CPU is also written to the Arduino.
                             17 ; 
                             18 ; Note: Currently, only the bottom two bits are used, but reserving the memory
                             19 ; this way insures that up to 5 bits could be used 
                             20 ; 
                             21         ; ROMIO READ Area - reserved
   87A0 FF FF FF FF FF FF    22         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
   87B0 FF FF FF FF FF FF    23         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
                             24 
                             25         ; ROMIO WRITE Area - data is used
   87C0 00 01 02 03 04 05    26         .DB     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
        06 07 08 09 0A 0B
        0C 0D 0E 0F
   87D0 10 11 12 13 14 15    27         .DB     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
        16 17 18 19 1A 1B
        1C 1D 1E 1F
                             28 
                             74 
                             75 ;------- region3  -----------------------------------------------
                             76 
                             77         .bank   region3 (base=IOEND, size=ROMEND-IOEND)
                             78         .area   region3 (ABS, BANK=region3)
                             79 
                             80 
