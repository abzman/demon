------- FILE ref6502.asm LEVEL 1 PASS 2
      1  10000 ????						;
      2  10000 ????						; Moniker - 6502 Version
      3  10000 ????						; by Frank Palazzolo
      4  10000 ????						; For ROM IO Hardware
      5  10000 ????						;
      6  10000 ????				       processor	6502
      7  10000 ????
      8  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      9  10000 ????						; You may need to adjust these variables for different targets
     10  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     11  10000 ????
     12  10000 ????						; RAM SETTINGS - usually in zero page
     13  10000 ????
     14  10000 ????		00 00	    RAMSTRT    equ	$00	;start of ram, needs 7 bytes starting here
     15  10000 ????		00 ff	    SSTACK     equ	$ff	;start of stack, needs some memory below this address
     16  10000 ????
     17  10000 ????						; ROM SETTINGS - usually the last 2K of memory for 6502
     18  10000 ????
     19  10000 ????		f8 00	    SCHIP      equ	$f800	;start of chip memory mapping
     20  10000 ????
     21  10000 ????		fc 00	    IOREG      equ	SCHIP+$0400	;reserved region for IO
     22  10000 ????		ff fa	    VECTORS    equ	SCHIP+$07fa	;reserved for vectors
     23  10000 ????
     24  10000 ????						; TIMER SETTING
     25  10000 ????		01 80	    BIGDEL     equ	$0180	;delay factor
     26  10000 ????
     27  10000 ????		00 11	    I2CRADR    equ	$11	;I2C read address  - I2C address 0x08
     28  10000 ????		00 10	    I2CWADR    equ	$10	;I2C write address - I2C address 0x08
     29  10000 ????
     30  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     31  10000 ????						; RAM Variables
     32  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     33  10000 ????
     34  10000 ????		00 00	    OUTBUF     equ	RAMSTRT	;buffer for output states
     35  10000 ????		00 01	    B	       equ	RAMSTRT+$01	;general purpose
     36  10000 ????		00 02	    C	       equ	RAMSTRT+$02	;general purpose
     37  10000 ????		00 03	    CMDBUF0    equ	RAMSTRT+$03	;command buffer
     38  10000 ????		00 04	    CMDBUF1    equ	RAMSTRT+$04	;command buffer
     39  10000 ????		00 05	    CMDBUF2    equ	RAMSTRT+$05	;command buffer
     40  10000 ????		00 06	    CMDBUF3    equ	RAMSTRT+$06	;command buffer
     41  10000 ????
     42  f800					      org	SCHIP	;last 2K of memory starts here
     43  f800
     44  f800		       ff ff ff ff*	      ds	$0600,$ff	; fill front and io regions with $FF
     45  fe00
     46  fe00							; Code fits into the last 512 bytes of memory
     47  fe00					      org	SCHIP+$0600	;code starts here
     48  fe00
     49  fe00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     50  fe00							; This function is called once, and should be used do any game-specific
     51  fe00							; initialization that is required
     52  fe00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     53  fe00
     54  fe00				   ONCE
     55  fe00							;	 YOUR CODE CAN GO HERE
     56  fe00		       60		      rts
     57  fe01
     58  fe01							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     59  fe01							; This function is called every time during the polling loop.	It can be
     60  fe01							; used to run watchdog code, etc.  I have provided a simple delay loop
     61  fe01							; so that the I2C slave is not overwhelmed
     62  fe01							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     63  fe01
     64  fe01				   EVERY
     65  fe01							;	 YOUR CODE CAN GO HERE
     66  fe01		       60		      rts
     67  fe02
     68  fe02							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     69  fe02							; Main Program code starts here
     70  fe02							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     71  fe02
     72  fe02							; NMI Handler
     73  fe02		       40	   NMI	      rti		;Don't do anything on an NMI
     74  fe03
     75  fe03		       a5 00	   SETSCL     lda	OUTBUF
     76  fe05		       09 01		      ora	#$01
     77  fe07		       85 00		      sta	OUTBUF
     78  fe09		       aa		      tax
     79  fe0a		       bd 00 fc 	      lda	IOREG,X
     80  fe0d		       20 3f fe 	      jsr	I2CDLY
     81  fe10		       60		      rts
     82  fe11
     83  fe11		       a5 00	   CLRSCL     lda	OUTBUF
     84  fe13		       29 fe		      and	#$fe
     85  fe15		       85 00		      sta	OUTBUF
     86  fe17		       aa		      tax
     87  fe18		       bd 00 fc 	      lda	IOREG,X
     88  fe1b		       60		      rts
     89  fe1c
     90  fe1c		       a5 00	   SETSDA     lda	OUTBUF
     91  fe1e		       29 fd		      and	#$fd
     92  fe20		       85 00		      sta	OUTBUF
     93  fe22		       aa		      tax
     94  fe23		       bd 00 fc 	      lda	IOREG,X
     95  fe26		       20 3f fe 	      jsr	I2CDLY
     96  fe29		       60		      rts
     97  fe2a
     98  fe2a		       a5 00	   CLRSDA     lda	OUTBUF
     99  fe2c		       09 02		      ora	#$02
    100  fe2e		       85 00		      sta	OUTBUF
    101  fe30		       aa		      tax
    102  fe31		       bd 00 fc 	      lda	IOREG,X
    103  fe34		       20 3f fe 	      jsr	I2CDLY
    104  fe37		       60		      rts
    105  fe38
    106  fe38		       a6 00	   READSDA    ldx	OUTBUF
    107  fe3a		       bd 00 fc 	      lda	IOREG,X
    108  fe3d		       6a		      ror
    109  fe3e		       60		      rts
    110  fe3f
    111  fe3f							; Delay for half a bit time
    112  fe3f		       60	   I2CDLY     rts		; TBD - this is plenty?
    113  fe40
    114  fe40							; I2C Start Condition
    115  fe40				   I2CSTART
    116  fe40		       20 2a fe 	      jsr	CLRSDA
    117  fe43		       20 11 fe 	      jsr	CLRSCL
    118  fe46		       60		      rts
    119  fe47
    120  fe47							; I2C Stop Condition
    121  fe47							; Uses HL
    122  fe47							; Destroys A
    123  fe47				   I2CSTOP
    124  fe47		       20 2a fe 	      jsr	CLRSDA
    125  fe4a		       20 03 fe 	      jsr	SETSCL
    126  fe4d		       20 1c fe 	      jsr	SETSDA
    127  fe50		       60		      rts
    128  fe51
    129  fe51				   I2CRBIT
    130  fe51		       20 1c fe 	      jsr	SETSDA
    131  fe54		       20 03 fe 	      jsr	SETSCL
    132  fe57		       20 38 fe 	      jsr	READSDA	; sets/clears carry flag
    133  fe5a		       20 11 fe 	      jsr	CLRSCL
    134  fe5d		       60		      rts		; carry flag still good here
    135  fe5e
    136  fe5e				   I2CWBIT
    137  fe5e		       90 06		      bcc	DOCLR
    138  fe60		       20 1c fe 	      jsr	SETSDA
    139  fe63		       4c 69 fe 	      jmp	AHEAD
    140  fe66				   DOCLR
    141  fe66		       20 2a fe 	      jsr	CLRSDA
    142  fe69				   AHEAD
    143  fe69		       20 03 fe 	      jsr	SETSCL
    144  fe6c		       20 11 fe 	      jsr	CLRSCL
    145  fe6f		       60		      rts
    146  fe70
    147  fe70				   I2CWBYTE
    148  fe70		       48		      pha
    149  fe71		       a9 08		      lda	#$08
    150  fe73		       85 01		      sta	B
    151  fe75		       68		      pla
    152  fe76				   ILOOP
    153  fe76		       2a		      rol
    154  fe77		       48		      pha
    155  fe78		       20 5e fe 	      jsr	I2CWBIT
    156  fe7b		       68		      pla
    157  fe7c		       c6 01		      dec	B
    158  fe7e		       d0 f6		      bne	ILOOP
    159  fe80		       20 51 fe 	      jsr	I2CRBIT
    160  fe83		       60		      rts
    161  fe84
    162  fe84				   I2CRBYTE
    163  fe84		       a9 08		      lda	#$08
    164  fe86		       85 01		      sta	B
    165  fe88		       a9 00		      lda	#$00
    166  fe8a		       85 02		      sta	C
    167  fe8c				   LOOP3
    168  fe8c		       20 51 fe 	      jsr	I2CRBIT	; get bit in carry flag
    169  fe8f		       26 02		      rol	C	; rotate carry into bit0 of C register
    170  fe91		       c6 01		      dec	B
    171  fe93		       d0 f7		      bne	LOOP3
    172  fe95		       18		      clc		; clear carry flag
    173  fe96		       20 5e fe 	      jsr	I2CWBIT
    174  fe99		       a5 02		      lda	C
    175  fe9b		       60		      rts
    176  fe9c
    177  fe9c				   I2CRREQ
    178  fe9c		       20 40 fe 	      jsr	I2CSTART
    179  fe9f		       a9 11		      lda	#I2CRADR
    180  fea1		       20 70 fe 	      jsr	I2CWBYTE
    181  fea4		       b0 17		      bcs	SKIP
    182  fea6		       20 84 fe 	      jsr	I2CRBYTE
    183  fea9		       85 03		      sta	CMDBUF0
    184  feab		       20 84 fe 	      jsr	I2CRBYTE
    185  feae		       85 04		      sta	CMDBUF1
    186  feb0		       20 84 fe 	      jsr	I2CRBYTE
    187  feb3		       85 05		      sta	CMDBUF2
    188  feb5		       20 84 fe 	      jsr	I2CRBYTE
    189  feb8		       85 06		      sta	CMDBUF3
    190  feba		       4c d1 fe 	      jmp	ENDI2C
    191  febd
    192  febd				   SKIP 		; If no device present, fake an idle response
    193  febd		       a9 2e		      lda	#$2e	; '.'
    194  febf		       85 03		      sta	CMDBUF0
    195  fec1		       4c d1 fe 	      jmp	ENDI2C
    196  fec4
    197  fec4				   I2CSRESP
    198  fec4		       48		      pha
    199  fec5		       20 40 fe 	      jsr	I2CSTART
    200  fec8		       a9 10		      lda	#I2CWADR
    201  feca		       20 70 fe 	      jsr	I2CWBYTE
    202  fecd		       68		      pla
    203  fece		       20 70 fe 	      jsr	I2CWBYTE
    204  fed1				   ENDI2C
    205  fed1		       20 47 fe 	      jsr	I2CSTOP
    206  fed4		       60		      rts
    207  fed5
    208  fed5				   POLL
    209  fed5		       20 9c fe 	      jsr	I2CRREQ
    210  fed8		       a5 03		      lda	CMDBUF0
    211  feda		       c9 52		      cmp	#$52	; 'R' - Read memory
    212  fedc		       f0 0a		      beq	MREAD
    213  fede		       c9 57		      cmp	#$57	; 'W' - Write memory
    214  fee0		       f0 10		      beq	MWRITE
    215  fee2		       c9 43		      cmp	#$43	; 'C' - Call subroutine
    216  fee4		       f0 26		      beq	REMCALL
    217  fee6		       18		      clc
    218  fee7		       60		      rts
    219  fee8
    220  fee8				   MREAD
    221  fee8		       20 fe fe 	      jsr	LOADBC
    222  feeb		       a0 00		      ldy	#$00
    223  feed		       b1 01		      lda	(B),Y
    224  feef		       4c 07 ff 	      jmp	SRESP
    225  fef2				   MWRITE
    226  fef2		       20 fe fe 	      jsr	LOADBC
    227  fef5		       a5 06		      lda	CMDBUF3
    228  fef7		       91 01		      sta	(B),Y
    229  fef9		       a9 57		      lda	#$57	;'W'
    230  fefb		       4c 07 ff 	      jmp	SRESP
    231  fefe				   LOADBC
    232  fefe		       a5 05		      lda	CMDBUF2
    233  ff00		       85 01		      sta	B
    234  ff02		       a5 04		      lda	CMDBUF1
    235  ff04		       85 02		      sta	C
    236  ff06		       60		      rts
    237  ff07
    238  ff07				   SRESP
    239  ff07		       20 c4 fe 	      jsr	I2CSRESP
    240  ff0a				   RHERE
    241  ff0a		       38		      sec
    242  ff0b		       60		      rts
    243  ff0c				   REMCALL
    244  ff0c		       a9 ff		      lda	#(START-1)>>8
    245  ff0e		       48		      pha
    246  ff0f		       a9 17		      lda	#(START-1)%256
    247  ff11		       48		      pha
    248  ff12		       20 fe fe 	      jsr	LOADBC
    249  ff15		       6c 01 00 	      jmp	(B)
    250  ff18
    251  ff18							;;;;;;;;;;
    252  ff18
    253  ff18				   START		; TBD- INIT Stack Pointer!
    254  ff18		       a2 ff		      ldx	#SSTACK
    255  ff1a		       9a		      txs		; Init stack
    256  ff1b		       d8		      cld		; No Decimal
    257  ff1c		       20 00 fe 	      jsr	ONCE
    258  ff1f
    259  ff1f							; Main routine
    260  ff1f				   MAIN
    261  ff1f		       20 01 fe 	      jsr	EVERY
    262  ff22		       20 d5 fe 	      jsr	POLL
    263  ff25		       b0 f8		      bcs	MAIN
    264  ff27
    265  ff27		       a9 01		      lda	#BIGDEL>>8
    266  ff29		       85 01		      sta	B
    267  ff2b		       a9 80		      lda	#BIGDEL%256
    268  ff2d		       85 02		      sta	C
    269  ff2f				   MLOOP
    270  ff2f		       a5 02		      lda	C
    271  ff31		       f0 05		      beq	DECBOTH
    272  ff33		       c6 02		      dec	C
    273  ff35		       4c 2f ff 	      jmp	MLOOP
    274  ff38				   DECBOTH
    275  ff38		       a5 01		      lda	B
    276  ff3a		       f0 e3		      beq	MAIN
    277  ff3c		       c6 02		      dec	C
    278  ff3e		       c6 01		      dec	B
    279  ff40		       4c 2f ff 	      jmp	MLOOP
    280  ff43
    281  ff43							;	 vectors
    282  ff43
    283  fffa					      org	SCHIP+$07fa
    284  fffa
    285  fffa		       02 fe		      dc.w	NMI
    286  fffc		       18 ff		      dc.w	START
    287  fffe		       18 ff		      dc.w	START
    288  10000
    289  10000
    290  10000
