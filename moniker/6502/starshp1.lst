------- FILE starshp1.asm LEVEL 1 PASS 2
      1  10000 ????						;
      2  10000 ????						; Moniker - 6502 Version
      3  10000 ????						; by Frank Palazzolo
      4  10000 ????						; For ROM IO Hardware - Atari Starship 1
      5  10000 ????						;
      6  10000 ????				       processor	6502
      7  10000 ????
      8  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      9  10000 ????						; You may need to adjust these variables for different targets
     10  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     11  10000 ????
     12  10000 ????						; RAM SETTINGS - usually in zero page
     13  10000 ????
     14  10000 ????		00 00	    RAMSTRT    equ	$00	;start of ram, needs 7 bytes starting here
     15  10000 ????		00 ff	    SSTACK     equ	$ff	;start of stack, needs some memory below this address
     16  10000 ????
     17  10000 ????						; ROM SETTINGS - usually the last 2K of memory for 6502
     18  10000 ????
     19  10000 ????		f8 00	    SCHIP      equ	$f800	;start of chip memory mapping
     20  10000 ????
     21  10000 ????		fc 00	    IOREG      equ	SCHIP+$0400	;reserved region for IO
     22  10000 ????
     23  10000 ????						; TIMER SETTING
     24  10000 ????		01 80	    BIGDEL     equ	$0180	;delay factor
     25  10000 ????
     26  10000 ????		00 11	    I2CRADR    equ	$11	;I2C read address  - I2C address 0x08
     27  10000 ????		00 10	    I2CWADR    equ	$10	;I2C write address - I2C address 0x08
     28  10000 ????
     29  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     30  10000 ????						; RAM Variables
     31  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     32  10000 ????
     33  10000 ????		00 00	    OUTBUF     equ	RAMSTRT	;buffer for output states
     34  10000 ????		00 01	    B	       equ	RAMSTRT+$01	;general purpose
     35  10000 ????		00 02	    C	       equ	RAMSTRT+$02	;general purpose
     36  10000 ????		00 03	    CMDBUF0    equ	RAMSTRT+$03	;command buffer
     37  10000 ????		00 04	    CMDBUF1    equ	RAMSTRT+$04	;command buffer
     38  10000 ????		00 05	    CMDBUF2    equ	RAMSTRT+$05	;command buffer
     39  10000 ????		00 06	    CMDBUF3    equ	RAMSTRT+$06	;command buffer
     40  10000 ????
     41  f800					      org	SCHIP	;last 2K of memory starts here
     42  f800
     43  f800		       ff ff ff ff*	      ds	$0600,$ff	; fill front and io regions with $FF
     44  fe00
     45  fe00							; Code fits into the last 512 bytes of memory
     46  fe00					      org	SCHIP+$0600	;code starts here
     47  fe00
     48  fe00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     49  fe00							; This function is called once, and should be used do any game-specific
     50  fe00							; initialization that is required
     51  fe00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     52  fe00
     53  fe00				   ONCE
     54  fe00							;	 YOUR CODE CAN GO HERE
     55  fe00		       60		      rts
     56  fe01
     57  fe01							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     58  fe01							; This function is called every time during the polling loop.	It can be
     59  fe01							; used to run watchdog code, etc.  I have provided a simple delay loop
     60  fe01							; so that the I2C slave is not overwhelmed
     61  fe01							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     62  fe01
     63  fe01				   EVERY
     64  fe01							; reset the starshp1 watchdog
     65  fe01		       a9 01		      lda	#$01
     66  fe03		       8d 06 dc 	      sta	$dc06
     67  fe06		       a9 fe		      lda	#$fe
     68  fe08		       8d 00 cc 	      sta	$cc00
     69  fe0b		       8d 00 cc 	      sta	$cc00
     70  fe0e		       8d 00 cc 	      sta	$cc00
     71  fe11		       8d 00 cc 	      sta	$cc00
     72  fe14		       8d 00 cc 	      sta	$cc00
     73  fe17		       8d 00 cc 	      sta	$cc00
     74  fe1a		       8d 00 cc 	      sta	$cc00
     75  fe1d		       8d 00 cc 	      sta	$cc00
     76  fe20		       8d 00 cc 	      sta	$cc00
     77  fe23		       8d 00 cc 	      sta	$cc00
     78  fe26		       8d 00 cc 	      sta	$cc00
     79  fe29		       8d 00 cc 	      sta	$cc00
     80  fe2c		       8d 00 cc 	      sta	$cc00
     81  fe2f		       8d 00 cc 	      sta	$cc00
     82  fe32		       8d 00 cc 	      sta	$cc00
     83  fe35		       8d 00 cc 	      sta	$cc00
     84  fe38		       8d 00 cc 	      sta	$cc00
     85  fe3b		       8d 00 cc 	      sta	$cc00
     86  fe3e		       8d 00 cc 	      sta	$cc00
     87  fe41		       8d 00 cc 	      sta	$cc00
     88  fe44		       8d 06 dc 	      sta	$dc06
     89  fe47
     90  fe47		       60		      rts
     91  fe48
     92  fe48							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     93  fe48							; Main Program code starts here
     94  fe48							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     95  fe48
     96  fe48							; NMI Handler
     97  fe48		       40	   NMI	      rti		;Don't do anything on an NMI
     98  fe49
     99  fe49		       a5 00	   SETSCL     lda	OUTBUF
    100  fe4b		       09 01		      ora	#$01
    101  fe4d		       85 00		      sta	OUTBUF
    102  fe4f		       aa		      tax
    103  fe50		       bd 00 fc 	      lda	IOREG,X
    104  fe53		       20 85 fe 	      jsr	I2CDLY
    105  fe56		       60		      rts
    106  fe57
    107  fe57		       a5 00	   CLRSCL     lda	OUTBUF
    108  fe59		       29 fe		      and	#$fe
    109  fe5b		       85 00		      sta	OUTBUF
    110  fe5d		       aa		      tax
    111  fe5e		       bd 00 fc 	      lda	IOREG,X
    112  fe61		       60		      rts
    113  fe62
    114  fe62		       a5 00	   SETSDA     lda	OUTBUF
    115  fe64		       29 fd		      and	#$fd
    116  fe66		       85 00		      sta	OUTBUF
    117  fe68		       aa		      tax
    118  fe69		       bd 00 fc 	      lda	IOREG,X
    119  fe6c		       20 85 fe 	      jsr	I2CDLY
    120  fe6f		       60		      rts
    121  fe70
    122  fe70		       a5 00	   CLRSDA     lda	OUTBUF
    123  fe72		       09 02		      ora	#$02
    124  fe74		       85 00		      sta	OUTBUF
    125  fe76		       aa		      tax
    126  fe77		       bd 00 fc 	      lda	IOREG,X
    127  fe7a		       20 85 fe 	      jsr	I2CDLY
    128  fe7d		       60		      rts
    129  fe7e
    130  fe7e		       a6 00	   READSDA    ldx	OUTBUF
    131  fe80		       bd 00 fc 	      lda	IOREG,X
    132  fe83		       6a		      ror
    133  fe84		       60		      rts
    134  fe85
    135  fe85							; Delay for half a bit time
    136  fe85		       60	   I2CDLY     rts		; TBD - this is plenty?
    137  fe86
    138  fe86							; I2C Start Condition
    139  fe86				   I2CSTART
    140  fe86		       20 70 fe 	      jsr	CLRSDA
    141  fe89		       20 57 fe 	      jsr	CLRSCL
    142  fe8c		       60		      rts
    143  fe8d
    144  fe8d							; I2C Stop Condition
    145  fe8d							; Uses HL
    146  fe8d							; Destroys A
    147  fe8d				   I2CSTOP
    148  fe8d		       20 70 fe 	      jsr	CLRSDA
    149  fe90		       20 49 fe 	      jsr	SETSCL
    150  fe93		       20 62 fe 	      jsr	SETSDA
    151  fe96		       60		      rts
    152  fe97
    153  fe97				   I2CRBIT
    154  fe97		       20 62 fe 	      jsr	SETSDA
    155  fe9a		       20 49 fe 	      jsr	SETSCL
    156  fe9d		       20 7e fe 	      jsr	READSDA	; sets/clears carry flag
    157  fea0		       20 57 fe 	      jsr	CLRSCL
    158  fea3		       60		      rts		; carry flag still good here
    159  fea4
    160  fea4				   I2CWBIT
    161  fea4		       90 06		      bcc	DOCLR
    162  fea6		       20 62 fe 	      jsr	SETSDA
    163  fea9		       4c af fe 	      jmp	AHEAD
    164  feac				   DOCLR
    165  feac		       20 70 fe 	      jsr	CLRSDA
    166  feaf				   AHEAD
    167  feaf		       20 49 fe 	      jsr	SETSCL
    168  feb2		       20 57 fe 	      jsr	CLRSCL
    169  feb5		       60		      rts
    170  feb6
    171  feb6				   I2CWBYTE
    172  feb6		       48		      pha
    173  feb7		       a9 08		      lda	#$08
    174  feb9		       85 01		      sta	B
    175  febb		       68		      pla
    176  febc				   ILOOP
    177  febc		       2a		      rol
    178  febd		       48		      pha
    179  febe		       20 a4 fe 	      jsr	I2CWBIT
    180  fec1		       68		      pla
    181  fec2		       c6 01		      dec	B
    182  fec4		       d0 f6		      bne	ILOOP
    183  fec6		       20 97 fe 	      jsr	I2CRBIT
    184  fec9		       60		      rts
    185  feca
    186  feca				   I2CRBYTE
    187  feca		       a9 08		      lda	#$08
    188  fecc		       85 01		      sta	B
    189  fece		       a9 00		      lda	#$00
    190  fed0		       85 02		      sta	C
    191  fed2				   LOOP3
    192  fed2		       20 97 fe 	      jsr	I2CRBIT	; get bit in carry flag
    193  fed5		       26 02		      rol	C	; rotate carry into bit0 of C register
    194  fed7		       c6 01		      dec	B
    195  fed9		       d0 f7		      bne	LOOP3
    196  fedb		       18		      clc		; clear carry flag
    197  fedc		       20 a4 fe 	      jsr	I2CWBIT
    198  fedf		       a5 02		      lda	C
    199  fee1		       60		      rts
    200  fee2
    201  fee2				   I2CRREQ
    202  fee2		       20 86 fe 	      jsr	I2CSTART
    203  fee5		       a9 11		      lda	#I2CRADR
    204  fee7		       20 b6 fe 	      jsr	I2CWBYTE
    205  feea		       b0 17		      bcs	SKIP
    206  feec		       20 ca fe 	      jsr	I2CRBYTE
    207  feef		       85 03		      sta	CMDBUF0
    208  fef1		       20 ca fe 	      jsr	I2CRBYTE
    209  fef4		       85 04		      sta	CMDBUF1
    210  fef6		       20 ca fe 	      jsr	I2CRBYTE
    211  fef9		       85 05		      sta	CMDBUF2
    212  fefb		       20 ca fe 	      jsr	I2CRBYTE
    213  fefe		       85 06		      sta	CMDBUF3
    214  ff00		       4c 17 ff 	      jmp	ENDI2C
    215  ff03
    216  ff03				   SKIP 		; If no device present, fake an idle response
    217  ff03		       a9 2e		      lda	#$2e	; '.'
    218  ff05		       85 03		      sta	CMDBUF0
    219  ff07		       4c 17 ff 	      jmp	ENDI2C
    220  ff0a
    221  ff0a				   I2CSRESP
    222  ff0a		       48		      pha
    223  ff0b		       20 86 fe 	      jsr	I2CSTART
    224  ff0e		       a9 10		      lda	#I2CWADR
    225  ff10		       20 b6 fe 	      jsr	I2CWBYTE
    226  ff13		       68		      pla
    227  ff14		       20 b6 fe 	      jsr	I2CWBYTE
    228  ff17				   ENDI2C
    229  ff17		       20 8d fe 	      jsr	I2CSTOP
    230  ff1a		       60		      rts
    231  ff1b
    232  ff1b				   POLL
    233  ff1b		       20 e2 fe 	      jsr	I2CRREQ
    234  ff1e		       a5 03		      lda	CMDBUF0
    235  ff20		       c9 52		      cmp	#$52	; 'R' - Read memory
    236  ff22		       f0 0a		      beq	MREAD
    237  ff24		       c9 57		      cmp	#$57	; 'W' - Write memory
    238  ff26		       f0 10		      beq	MWRITE
    239  ff28		       c9 43		      cmp	#$43	; 'C' - Call subroutine
    240  ff2a		       f0 26		      beq	REMCALL
    241  ff2c		       18		      clc
    242  ff2d		       60		      rts
    243  ff2e
    244  ff2e				   MREAD
    245  ff2e		       20 44 ff 	      jsr	LOADBC
    246  ff31		       a0 00		      ldy	#$00
    247  ff33		       b1 01		      lda	(B),Y
    248  ff35		       4c 4d ff 	      jmp	SRESP
    249  ff38				   MWRITE
    250  ff38		       20 44 ff 	      jsr	LOADBC
    251  ff3b		       a5 06		      lda	CMDBUF3
    252  ff3d		       91 01		      sta	(B),Y
    253  ff3f		       a9 57		      lda	#$57	;'W'
    254  ff41		       4c 4d ff 	      jmp	SRESP
    255  ff44				   LOADBC
    256  ff44		       a5 05		      lda	CMDBUF2
    257  ff46		       85 01		      sta	B
    258  ff48		       a5 04		      lda	CMDBUF1
    259  ff4a		       85 02		      sta	C
    260  ff4c		       60		      rts
    261  ff4d
    262  ff4d				   SRESP
    263  ff4d		       20 0a ff 	      jsr	I2CSRESP
    264  ff50				   RHERE
    265  ff50		       38		      sec
    266  ff51		       60		      rts
    267  ff52				   REMCALL
    268  ff52		       a9 ff		      lda	#(START-1)>>8
    269  ff54		       48		      pha
    270  ff55		       a9 5d		      lda	#(START-1)%256
    271  ff57		       48		      pha
    272  ff58		       20 44 ff 	      jsr	LOADBC
    273  ff5b		       6c 01 00 	      jmp	(B)
    274  ff5e
    275  ff5e							;;;;;;;;;;
    276  ff5e
    277  ff5e				   START		; TBD- INIT Stack Pointer!
    278  ff5e		       a2 ff		      ldx	#SSTACK
    279  ff60		       9a		      txs		; Init stack
    280  ff61		       d8		      cld		; No Decimal
    281  ff62		       20 00 fe 	      jsr	ONCE
    282  ff65
    283  ff65							; Main routine
    284  ff65				   MAIN
    285  ff65		       20 01 fe 	      jsr	EVERY
    286  ff68		       20 1b ff 	      jsr	POLL
    287  ff6b		       b0 f8		      bcs	MAIN
    288  ff6d
    289  ff6d		       a9 01		      lda	#BIGDEL>>8
    290  ff6f		       85 01		      sta	B
    291  ff71		       a9 80		      lda	#BIGDEL%256
    292  ff73		       85 02		      sta	C
    293  ff75				   MLOOP
    294  ff75		       a5 02		      lda	C
    295  ff77		       f0 05		      beq	DECBOTH
    296  ff79		       c6 02		      dec	C
    297  ff7b		       4c 75 ff 	      jmp	MLOOP
    298  ff7e				   DECBOTH
    299  ff7e		       a5 01		      lda	B
    300  ff80		       f0 e3		      beq	MAIN
    301  ff82		       c6 02		      dec	C
    302  ff84		       c6 01		      dec	B
    303  ff86		       4c 75 ff 	      jmp	MLOOP
    304  ff89
    305  ff89							;	 vectors
    306  ff89
    307  fffa					      org	SCHIP+$07fa
    308  fffa
    309  fffa		       48 fe		      dc.w	NMI
    310  fffc		       5e ff		      dc.w	START
    311  fffe		       5e ff		      dc.w	START
    312  10000
    313  10000
    314  10000
