                              1 
                              2         .include "../6502/settings.asm"
                              1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              2 ; You may need to adjust these variables for different targets
                              3 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              4 
                              5 ; RAM SETTINGS - usually in zero page
                              6 
                     0000     7 RAMSTRT .equ    0x00    ;start of ram, needs 7 bytes starting here
                     00FF     8 SSTACK	.equ	0xff	;start of stack, needs some memory below this address
                              9 
                             10 ; ROM SETTINGS - usually the last 2K of memory for 6502
                             11 
                     F800    12 STRTADD .equ    0xf800      ; start of chip memory mapping
                             13 
                             14 ; TIMER SETTING
                     0180    15 BIGDEL  .equ    0x0180      ; delay factor
                             16 
                             17 ; I2C ADDRESSING
                     0011    18 I2CRADR .equ    0x11        ; I2C read address  - I2C address 0x08
                     0010    19 I2CWADR .equ    0x10        ; I2C write address - I2C address 0x08
                             20 
                             21 ; VECTORS
                     FFFA    22 VECTORS .equ    STRTADD+0x07fa
                             23 
                             24 
                             25 
                             26 
                              3         .include "../romio/defs.asm"
                              1 ; For Demon Debugger Hardware - Rev D 
                              2 
                     FFA0     3 IOREGR   .equ   STRTADD+0x07a0    ;reserved region for IO READ
                     FFC0     4 IOREGW   .equ   STRTADD+0x07c0    ;reserved region for IO WRITE
                              5 
                     FFA0     6 IOADD    .equ   IOREGR            ;start of region
                              4 
                              5         ; This section must end before the IO Region
                              6         .bank   first   (base=STRTADD, size=IOADD-STRTADD)
                              7         .area   first   (ABS, BANK=first)
                              8 
                              9         .include "../6502/startup.asm"
                              1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              2 ; This function is called once, and should be used do any game-specific
                              3 ; initialization that is required
                              4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              5 
   F800                       6 ONCE:
                              7 ;       YOUR CODE CAN GO HERE
   F800 60            [ 6]    8         rts
                             10         .include "../6502/loop.asm"
                              1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              2 ; This function is called every time during the polling loop.  It can be
                              3 ; used to run watchdog code, etc.  I have provided a simple delay loop
                              4 ; so that the I2C slave is not overwhelmed
                              5 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              6 
   F801                       7 EVERY:
                              8 ;       YOUR CODE CAN GO HERE
   F801 60            [ 6]    9         rts
                             11         .include "../6502/nmi.asm"
                              1 ; NMI Handler
   F802 40            [ 6]    2 NMI:	rti             ;Don't do anything on an NMI
                             12         .include "../6502/romio.asm" 
   F803 A5 00         [ 3]    1 SETSCL:	lda	OUTBUF
   F805 09 01         [ 2]    2 	ora	#0x01
   F807 85 00         [ 3]    3         sta     OUTBUF
   F809 AA            [ 2]    4         tax
   F80A BD C0 FF      [ 5]    5         lda     IOREGW,X
   F80D 20 3F F8      [ 6]    6 	jsr	I2CDLY
   F810 60            [ 6]    7 	rts
                              8 
   F811 A5 00         [ 3]    9 CLRSCL:	lda	OUTBUF
   F813 29 1E         [ 2]   10     and	#0x1e
   F815 85 00         [ 3]   11     sta	OUTBUF
   F817 AA            [ 2]   12         tax
   F818 BD C0 FF      [ 5]   13         lda     IOREGW,X
   F81B 60            [ 6]   14 	rts
                             15 
   F81C A5 00         [ 3]   16 SETSDA:	lda	OUTBUF
   F81E 29 1D         [ 2]   17 	and	#0x1d
   F820 85 00         [ 3]   18         sta     OUTBUF
   F822 AA            [ 2]   19         tax
   F823 BD C0 FF      [ 5]   20         lda     IOREGW,X
   F826 20 3F F8      [ 6]   21 	jsr	I2CDLY
   F829 60            [ 6]   22 	rts
                             23 
   F82A A5 00         [ 3]   24 CLRSDA:	lda	OUTBUF
   F82C 09 02         [ 2]   25 	ora	#0x02
   F82E 85 00         [ 3]   26         sta     OUTBUF
   F830 AA            [ 2]   27         tax
   F831 BD C0 FF      [ 5]   28         lda     IOREGW,X
   F834 20 3F F8      [ 6]   29 	jsr	I2CDLY
   F837 60            [ 6]   30 	rts
                             31 
   F838 A6 00         [ 3]   32 READSDA:	ldx	OUTBUF
   F83A BD A0 FF      [ 5]   33         lda     IOREGR,X
   F83D 6A            [ 2]   34         ror
   F83E 60            [ 6]   35 	rts				
                             13         .include "../6502/main.asm"
                              1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              2 ; RAM Variables	
                              3 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              4 
                     0000     5 OUTBUF	.equ	RAMSTRT	        ;buffer for output states
                     0001     6 B	.equ	RAMSTRT+0x01	;general purpose
                     0002     7 C	.equ	RAMSTRT+0x02	;general purpose
                     0003     8 CMDBUF0 .equ	RAMSTRT+0x03	;command buffer
                     0004     9 CMDBUF1 .equ	RAMSTRT+0x04	;command buffer
                     0005    10 CMDBUF2 .equ	RAMSTRT+0x05	;command buffer
                     0006    11 CMDBUF3 .equ	RAMSTRT+0x06	;command buffer
                             12 
                             13 ; Delay for half a bit time
   F83F 60            [ 6]   14 I2CDLY:	rts		; TBD - this is plenty?
                             15 
                             16 ; I2C Start Condition
   F840                      17 I2CSTART:
   F840 20 2A F8      [ 6]   18         jsr    CLRSDA      
   F843 20 11 F8      [ 6]   19         jsr    CLRSCL
   F846 60            [ 6]   20         rts
                             21 
                             22 ; I2C Stop Condition
                             23 ; Uses HL
                             24 ; Destroys A
   F847                      25 I2CSTOP:
   F847 20 2A F8      [ 6]   26         jsr    CLRSDA
   F84A 20 03 F8      [ 6]   27         jsr    SETSCL
   F84D 20 1C F8      [ 6]   28         jsr    SETSDA
   F850 60            [ 6]   29         rts
                             30         
   F851                      31 I2CRBIT:
   F851 20 1C F8      [ 6]   32 	jsr	SETSDA
   F854 20 03 F8      [ 6]   33 	jsr	SETSCL
   F857 20 38 F8      [ 6]   34 	jsr	READSDA	; sets/clears carry flag
   F85A 20 11 F8      [ 6]   35 	jsr     CLRSCL
   F85D 60            [ 6]   36 	rts		; carry flag still good here
                             37 
   F85E                      38 I2CWBIT:
   F85E 90 06         [ 4]   39 	bcc	DOCLR
   F860 20 1C F8      [ 6]   40 	jsr	SETSDA
   F863 4C 69 F8      [ 3]   41 	jmp	AHEAD
   F866                      42 DOCLR:
   F866 20 2A F8      [ 6]   43 	jsr	CLRSDA
   F869                      44 AHEAD:
   F869 20 03 F8      [ 6]   45 	jsr	SETSCL
   F86C 20 11 F8      [ 6]   46 	jsr	CLRSCL
   F86F 60            [ 6]   47 	rts
                             48         
   F870                      49 I2CWBYTE:
   F870 48            [ 3]   50 	pha
   F871 A9 08         [ 2]   51 	lda	#0x08
   F873 85 01         [ 3]   52 	sta	B
   F875 68            [ 4]   53 	pla
   F876                      54 ILOOP:
   F876 2A            [ 2]   55 	rol
   F877 48            [ 3]   56 	pha
   F878 20 5E F8      [ 6]   57 	jsr	I2CWBIT
   F87B 68            [ 4]   58 	pla
   F87C C6 01         [ 5]   59 	dec	B
   F87E D0 F6         [ 4]   60 	bne	ILOOP
   F880 20 51 F8      [ 6]   61 	jsr	I2CRBIT
   F883 60            [ 6]   62 	rts
                             63 	
   F884                      64 I2CRBYTE:
   F884 A9 08         [ 2]   65         lda	#0x08
   F886 85 01         [ 3]   66 	sta	B
   F888 A9 00         [ 2]   67 	lda	#0x00
   F88A 85 02         [ 3]   68 	sta	C
   F88C                      69 LOOP3:
   F88C 20 51 F8      [ 6]   70         jsr     I2CRBIT     ; get bit in carry flag
   F88F 26 02         [ 5]   71         rol     C           ; rotate carry into bit0 of C register
   F891 C6 01         [ 5]   72         dec	B
   F893 D0 F7         [ 4]   73         bne    	LOOP3
   F895 18            [ 2]   74         clc           	    ; clear carry flag              
   F896 20 5E F8      [ 6]   75         jsr   	I2CWBIT
   F899 A5 02         [ 3]   76         lda  	C
   F89B 60            [ 6]   77         rts
                             78 
   F89C                      79 I2CRREQ:
   F89C 20 40 F8      [ 6]   80         jsr     I2CSTART
   F89F A9 11         [ 2]   81         lda	#I2CRADR
   F8A1 20 70 F8      [ 6]   82         jsr     I2CWBYTE
   F8A4 B0 17         [ 4]   83         bcs     SKIP
   F8A6 20 84 F8      [ 6]   84         jsr     I2CRBYTE
   F8A9 85 03         [ 3]   85         sta     CMDBUF0
   F8AB 20 84 F8      [ 6]   86         jsr     I2CRBYTE
   F8AE 85 04         [ 3]   87         sta     CMDBUF1
   F8B0 20 84 F8      [ 6]   88         jsr     I2CRBYTE
   F8B3 85 05         [ 3]   89         sta     CMDBUF2
   F8B5 20 84 F8      [ 6]   90         jsr     I2CRBYTE
   F8B8 85 06         [ 3]   91         sta     CMDBUF3
   F8BA 4C D1 F8      [ 3]   92         jmp     ENDI2C
                             93     
   F8BD                      94 SKIP:                       ; If no device present, fake an idle response
   F8BD A9 2E         [ 2]   95         lda     #0x2e  ; '.'
   F8BF 85 03         [ 3]   96         sta     CMDBUF0
   F8C1 4C D1 F8      [ 3]   97         jmp     ENDI2C
                             98 
   F8C4                      99 I2CSRESP:
   F8C4 48            [ 3]  100         pha
   F8C5 20 40 F8      [ 6]  101         jsr     I2CSTART
   F8C8 A9 10         [ 2]  102         lda     #I2CWADR
   F8CA 20 70 F8      [ 6]  103         jsr     I2CWBYTE
   F8CD 68            [ 4]  104         pla
   F8CE 20 70 F8      [ 6]  105         jsr     I2CWBYTE
   F8D1                     106 ENDI2C:
   F8D1 20 47 F8      [ 6]  107         jsr     I2CSTOP
   F8D4 60            [ 6]  108         rts
                            109 
   F8D5                     110 POLL:
   F8D5 20 9C F8      [ 6]  111         jsr     I2CRREQ
   F8D8 A5 03         [ 3]  112         lda     CMDBUF0
   F8DA C9 52         [ 2]  113         cmp     #0x52    	; 'R' - Read memory
   F8DC F0 0A         [ 4]  114         beq     MREAD
   F8DE C9 57         [ 2]  115         cmp     #0x57    	; 'W' - Write memory
   F8E0 F0 10         [ 4]  116         beq	MWRITE
   F8E2 C9 43         [ 2]  117         cmp     #0x43    	; 'C' - Call subroutine
   F8E4 F0 26         [ 4]  118         beq	REMCALL
   F8E6 18            [ 2]  119         clc
   F8E7 60            [ 6]  120         rts
                            121 
   F8E8                     122 MREAD:
   F8E8 20 FE F8      [ 6]  123         jsr     LOADBC
   F8EB A0 00         [ 2]  124         ldy	#0x00
   F8ED B1 01         [ 6]  125         lda	[B],Y
   F8EF 4C 07 F9      [ 3]  126         jmp     SRESP
   F8F2                     127 MWRITE:
   F8F2 20 FE F8      [ 6]  128         jsr     LOADBC
   F8F5 A5 06         [ 3]  129         lda     CMDBUF3
   F8F7 91 01         [ 6]  130         sta     [B],Y
   F8F9 A9 57         [ 2]  131         lda     #0x57  	;'W'
   F8FB 4C 07 F9      [ 3]  132         jmp     SRESP
   F8FE                     133 LOADBC:
   F8FE A5 05         [ 3]  134 	lda	CMDBUF2
   F900 85 01         [ 3]  135 	sta	B
   F902 A5 04         [ 3]  136 	lda	CMDBUF1
   F904 85 02         [ 3]  137 	sta	C
   F906 60            [ 6]  138 	rts
                            139 	
   F907                     140 SRESP:
   F907 20 C4 F8      [ 6]  141         jsr    I2CSRESP
   F90A                     142 RHERE:
   F90A 38            [ 2]  143         sec
   F90B 60            [ 6]  144         rts
   F90C                     145 REMCALL:
   F90C A9 F9         [ 2]  146 	lda	#>(START-1)
   F90E 48            [ 3]  147         pha
   F90F A9 17         [ 2]  148         lda	#<(START-1)
   F911 48            [ 3]  149         pha
   F912 20 FE F8      [ 6]  150         jsr     LOADBC
   F915 6C 01 00      [ 5]  151         jmp     [B]
                            152         
                            153 ;;;;;;;;;;
                            154 	
   F918                     155 START:
   F918 78            [ 2]  156         sei             ; disable interrupts
   F919 A2 FF         [ 2]  157 	ldx	#SSTACK
   F91B 9A            [ 2]  158 	txs		; Init stack
   F91C D8            [ 2]  159 	cld		; No Decimal
   F91D A9 00         [ 2]  160         lda     #0x00
   F91F 85 00         [ 3]  161         sta     OUTBUF
   F921 20 00 F8      [ 6]  162         jsr     ONCE
                            163 
                            164 ; Main routine
   F924                     165 MAIN:
   F924 20 01 F8      [ 6]  166         jsr     EVERY
   F927 20 D5 F8      [ 6]  167         jsr     POLL
   F92A B0 F8         [ 4]  168         bcs     MAIN
   F92C A9 01         [ 2]  169         lda	#BIGDEL>>8
   F92E 85 01         [ 3]  170         sta	B
   F930 A9 80         [ 2]  171         lda	#BIGDEL%256
   F932 85 02         [ 3]  172         sta	C
   F934                     173 MLOOP:
   F934 A5 02         [ 3]  174         lda	C
   F936 F0 05         [ 4]  175         beq	DECBOTH
   F938 C6 02         [ 5]  176         dec	C
   F93A 4C 34 F9      [ 3]  177         jmp	MLOOP
   F93D                     178 DECBOTH:
   F93D A5 01         [ 3]  179 	lda	B
   F93F F0 E3         [ 4]  180 	beq	MAIN
   F941 C6 02         [ 5]  181 	dec	C
   F943 C6 01         [ 5]  182 	dec	B
   F945 4C 34 F9      [ 3]  183 	jmp	MLOOP
                             14 
                             15         .include "../romio/table.asm"
                              1 
                              2 ; 
                              3 ; For Demon Debugger Hardware - Rev D 
                              4 ;
                              5 ; In earlier hardware designs, I tried to capture the address bus bits on a 
                              6 ; read cycle, to use to write to the Arduino.  But it turns out it is impossible
                              7 ; to know exactly when to sample these address bits across all platforms, designs, and 
                              8 ; clock speeds
                              9 ;
                             10 ; The solution I came up with was to make sure the data bus contains the same information
                             11 ; as the lower address bus during these read cycles, so that I can sample the data bus just like the 
                             12 ; CPU would.
                             13 ;
                             14 ; This block of memory, starting at 0x07c0, is filled with consecutive integers.
                             15 ; When the CPU reads from a location, the data bus matches the lower bits of the address bus.  
                             16 ; And the data bus read by the CPU is also written to the Arduino.
                             17 ; 
                             18 ; Note: Currently, only the bottom two bits are used, but reserving the memory
                             19 ; this way insures that up to 5 bits could be used 
                             20 ; 
                             21         .bank   iowritebank   (base=IOREGW, size=0x20)
                             22         .area   iowritearea   (ABS, BANK=iowritebank)
                             23 
   FFC0 00 01 02 03 04 05    24         .DB     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
        06 07 08 09 0A 0B
        0C 0D 0E 0F
   FFD0 10 11 12 13 14 15    25         .DB     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
        16 17 18 19 1A 1B
        1C 1D 1E 1F
                             26 
                             16 
                             17         .include "../6502/vectors.asm"
                              1 	
                              2         .bank   vectorbank   (base=VECTORS, size=0x06)
                              3         .area   vectorarea   (ABS, BANK=vectorbank)
                              4 
   FFFA 02 F8                 5 	.dw	NMI
   FFFC 18 F9                 6 	.dw	START
   FFFE 18 F9                 7 	.dw	START
